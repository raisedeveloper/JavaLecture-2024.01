*어제 배운 내용
인터페이스의 코드로만 작성하기
리스트-리스트 = 뉴 어레이 리스트(리스트로 구현한 객체가 어레이 리스트)
Set set new hashtag?
Set set new hashmap?

자바는 최소한 편의점 수준의 언어

인터페이스를 구현하기 위해 구현객체를 바로 만들어서 DAO 역할을 할 수 있지만
DAO를 만들어서 구현객체가 Oracle 다오에게 정보를 주는 형태

DAO를 만들고
구현객체하고 DAO랑 연계를 맺어줌
결과 받아서 던져주는 일
만약 혹시라도 DB에 특화된 특성이 있으면 그것을 조금 살려주면 됨
여러개의 DB를 쓸 수 있는 아주 효율적인 방법
interface 만들어놨던 것하고 DAO와 연계하는 구현객체만 만들었음(어제)

application은 인터페이스에 있는 정의된 메소드를 사용 (MessageService 인터페이스 단)


MessageDAO 단: 2024-02-07 09:24:30 이럴 때
DB 조회 결과 : LocalDateTime.parse(구현객체로 만들고 싶을 때 사용하는 메소드)("2024-02-07T09:24:30"); 
		중간에 T를 가져다 붙이기 79번째 줄 (Teacher GitHub) 
Message m = new Message(rs.getInt(1), rs.getString(2), 
		rs.getString(3), LocalDateTime.parse(rs.getString(4).replace(" ", "T"), 0);

MessageSeriveMySQLImpl 단
구현한 클래스 안에서는 어디서든지 쓸 수 있는 msgDao 
mid 변수를 받아서 mid에 변수를 DAO에게 주고 결과를 받아서 결과를 데이터 저장소로, 
Application에 전달

getMessageListAll 몽땅 다 가져오는 것
getMessageListByWriter 작성자가 쓴 글만 가져오는 것
파라메터 없이 들어오는 것도 내가 파라메터 만들어서 데이터를 전달할 수도 있음

insert update delete는 받아서 정보를 던져주면 더 이상 할 것이 없음

형식만 맞춰주는 코드만 입력해주면 저렇게 하라고 만들어져 있음
그것이 스프링 부트가 하는 일

저 방식이 스프링부트에서 구현할 방식이기 때문에 먼저 알고잇는 것이 도움됨
형식맞춰주는 코드 자꾸 보기

MessageTest를 DAO를 테스트하는 단
MessageMain은 어플리케이션
구현객체를 이렇게 만듬

구현객체는 메세지 다오에 종속적이다
디펜던트하다
메세지 다오가 바뀌면 구현객체도 바뀌어야함
그런데 나중에는 종속이라고 하는 의존성을 나중에는 스프링이 자동으로 인셉션해줌

private Message Dao msg Dao = new MessageDao();
나중에는 이 코드가 이러헥 변함 == @Autowired private Message msgDao;
객체를 생성하지 않았지만 그런데 이렇게만 써 놓아도 구현객체가 msgDao를 쓸 수 있게됨
스프링이 구현객체를 만들어서 넣어줌
디펜던시 000 의존성 주입???

현상 발생 : MessageService messageService = new MessageServiceMySQLImpl(); 
앞으로 바뀔 코드 == 앞으로는 메인에서 웹 작업할 일 없음
@Autowired private MessageService messageService;
뒤에 무엇이 오든 코드가 바뀔 일이 없음
내 application은 무엇이 되던지 DB가 무엇이 되든간에 코드를 고칠 일이 없음
모든 DB에 같은 코드를 사용할 수 있게됨
인터페이스에서 알려준 코드를 썼음
MessageMain은 바꿀 필요가 없게됨
데이터를 인터넷으로부터 받는 것만 달라짐 _ 어플리케이션이 대단한 것이 아님
DB를 쓸 것인데 CRUD를 어떻게 사용자화면으로 바꿔 줄 것인가가 중요함


암호화(Crypt) 
1. 복원 가능한 암호화 
-평문을 비문으로 바꿀 수 있음
비문을 평문으로 바꿀 수 있음
위와 같은 것이 복원 가능한 알고리즘임
- 공개키 알고리즘이라고 부름 (복원이 가능하려면 키를 두개를 가져야함)
1. 개인키
2. 공개키
암호화를 할 때 개인키와 공개키를 가지고 작업을 함

2. 비복원 암호화
- 한쪽으로는 가능하나 비문을 평문으로 바꿀 수 없음
위와 같은 것을 비복원 암호화라고 함
대표적인 것이 로그인 작업임
로그인 가능한 패스워드를 입력할 때(암호화할 때) 암호를 설정한 것은 절대로 알 수 없음


평문 		-> 		비문

plain text			cyper text ? cipher text?



-60
$2a$10$Q1fxc6wTqDLL1s4YSLEfwOvgTXmvTnjYniZohteGi.rybAI.aM2FW
암호화된 코드는 char(60)

Correct id
Imbelled Uid 
Incorrect Psw
세 가지의 경우가 있다
== 코드로 나타내면 이하와 같음 
	public static final int correct_login = 0;
	public static final int WRONG_PASSWORD = 1;
	public static final int USER_NOT_EXIST= 2;


1000건 가정 3번쨰 페이지 라면
내가 보아야 할 글자의 갯수는 10개 count per page
offset =2 
page = 3
page-1
int offset = page-1 * count per page작성
